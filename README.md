# Delegates


## block 1: таймер

у цьому блоці нам потрібно було написати клас Timer який приймає в себе метод та через який час його потрібно повторювати. щоб передати метод в конструктор нашого таймеру ми використали делегат `public delegate void Method();`. Кожен таймер створюється в окремому потоці, при зупинці таймера цей поток завершується. замість кастомного делегата можна використати `Action`.

## block 2: фільтр

у цьому блоці нам потрібно було відфільтрувати масив цілих чисел, за параметром, заданим в лямбда-виразі, що призначений делегату `delegate bool Filter(int n);` замість якого можна використати `Func<int, bool>`. цей делегат передається у два методи:

1) фільтрація за допомогою LINQ, ключове слово `Where`. якщо передати число в метод фільтрації і він поверне `true` - ми його залишаємо. якщо `false` - відкидаємо.

2) ручна фільтрація, аналогічна, але написана руцями.

## block3: сума ряду

у цьому блоці я використала вбудований делегат `Func<int, double>`, в який передаю лямбда вирази для `x`, які описують елементи ряду. Щоб знайти суму ряду, `n` разів сумуємо n-ті елементи ряду. для `n>=20` точність більш ніж задовільна.


## block4: функціональний калькулятор

у цьому блоці нам потрібно було написати калькулятор який приймає ввід у форматі `n x` де `n` - номер функції, а `x` - аргумент функції. для цього було використано вбудований делегат `Func<int, double>`, в який передаю лямбда вирази для `x`, які описують функції. далі я роблю масив цих функції. наступним кроком в нескінченному циклі приймаю аргументи `n` - номер функції та `x` - аргумент, викликаю n-ту функцію з аргументом `x` та друкую результат.


## block5: суперкнопка

простий wpf-додаток, 3 чекбокси, 4 кнопки.

1) змінює колір через властивіть вікна

2) змінює прозорість через властивіть вікна (через особливість wpf, довелося зробити кастомну верхню панель з кнопкою закриття програми)

3) виводить алерт-бокс з привітанням

`якщо чекбокс натиснутий (подія спрацювала), на цю кнопку вішаємо дію`

Суперкнопка: на ній висить обробник подій `RoutedEventHandler`, який оглядає які події (`RoutedEventArgs`) відбулися (чекбокси натиснуті). і прив'язує їх до кнопки (`superButton.Click += handler`) або відв'язує (`superButton.Click -= handler`)

## block 6

### : структура програми

Програма складається з кількох класів:

* `Program` — головне меню, з якого викликаються інші модулі.
* `SortingAlgorithms` — містить реалізації сортувальних алгоритмів: як еталонних (`SelectionSort`, `ShakerSort`), так і студентських (`StudentSelectionSort`, `StudentShakerSort`).
* `SortingTester` — відповідає за тестування алгоритмів. Порівнює результат студента з еталоном та заміряє час виконання.
* `TestDataGenerator` — створює тестові масиви цілих чисел у текстових файлах.

Усе оформлено в процедурно-об’єктному стилі. Кожен функціональний блок винесений окремо.

### делегати

Для передачі алгоритмів сортування як параметрів використовуються делегати:

```csharp
public delegate void SortMethod(int[] array);
```

Також використовується делегат:

```csharp
public delegate bool TimeVerifier(long etalonTime, long studentTime);
```

Це дозволяє гнучко визначати критерії проходження тестів.

###логіка тестування

Метод `TestSorting` приймає два методи сортування (еталонний і студентський) і масив. Після виконання обох варіантів:

* перевіряє, чи масиви однакові (`SequenceEqual`)
* перевіряє, чи час студента вкладається в заданий ліміт (у 2 рази повільніше + 50 мс)

Результат повертається у вигляді булевого значення + додатково повідомляється про причину невдачі (`WA`, `TL`, `CE`).

### формат тестів

Тестові масиви зберігаються у форматі `.txt`, у папці `TestArrays`. Кожен файл — це масив цілих чисел, розділених пробілами. Кількість тестів і розмір масивів задається параметрами генератора (`n`, `k`).

### меню та взаємодія з користувачем

Програма запускає нескінченне меню:

1. Генерація тестів
2. Перевірка Selection Sort
3. Перевірка Shaker Sort
4. Вихід

Користувач обирає пункт, результат виводиться в консоль з кольоровим маркуванням. Наприкінці кожного тестування виводиться зведена оцінка у відсотках.

### реалізація студентських алгоритмів

Для перевірки використовуються дві окремі реалізації студентом:

* `StudentSelectionSort` — сортування вибором
* `StudentShakerSort` — коктейльне сортування
